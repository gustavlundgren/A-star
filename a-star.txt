var NODESIZE = 20

var path

var openSet = new Set()
var closedSet = new Set()
var gridPointsByPos = []
var gridPoints = []

var wallSet = new Set

//lagra start och stopp vid reset 
var startPoint
var endPoint

var mode = null

  
class Grid {
  constructor(width, height, posx, posy, gridPoints) {
    this.width = width
    this.height = height
    this.posx = posx
    this.posy = posy
    this.gridPoints = gridPoints

  }

  createGrid() {
    var tempNode
    var countNodes = 0
    ctx.beginPath()
    ctx.lineWidth = "1"
    ctx.strokeStyle = "black"
    ctx.rect(0, 0, this.width, this.height)
    ctx.stroke()

    for (var i = 0; i < this.width; i += NODESIZE) {
      gridPointsByPos[i] = []

      for (var j = 0; j < this.height; j += NODESIZE) {
        gridPointsByPos[i][j] = countNodes
        //here's the problem , need to set the walkability of the node without always being true...
        tempNode = new Node(countNodes, NODESIZE, i, j, true)
        if (countNodes === 53 || countNodes === 93 || countNodes === 133 || countNodes === 173 || countNodes === 213 || countNodes === 253 || countNodes === 293 || countNodes === 333) {
          tempNode.walkable = false;

        }
        if (wallSet.has(countNodes)) {
          console.log("wallSet had countNodes!")
          tempNode.walkable = false
        }

        tempNode.drawNode()
        tempNode.F = tempNode.getValueF()
        gridPoints.push(tempNode)

        countNodes++

      }
    }
  }

}


class Vec2 {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}


startPoint = new Vec2(40, 80)
endPoint = new Vec2(100, 400)



class Node {

  constructor(id, size, posx, posy, walkable) {
    var F

    var parent
    this.inPath = false
    this.getGCost = this.getValueG
    this.getHCost = this.getValueH

    this.size = size
    this.posx = posx
    this.posy = posy
    this.walkable = walkable

    this.id = id

  }

  createStartNode() {
    nodeDrawer(ctx, this, 2, "black", "blue")

  }
  createEndNode() {
    nodeDrawer(ctx, this, 2, "black", "red")

  }
  toggleWalkable() {
    this.walkable = !this.walkable
  }
  getValueF() {
    //this is a problem
    var fValue = (this.getValueH()) + (this.getValueG())

    return (fValue)
  }
  getValueH() {
    var endNodePosition = {
      posx: endPoint.x,
      posy: endPoint.y
    }

    return (getDistance(this, endNodePosition))

  }
  getValueG() {
    var startPointPosition = {
      posx: endPoint.x,
      posy: endPoint.y
    }
    return (getDistance(this, startPointPosition))
  }
  createWall() {
    nodeDrawer(ctx, this, 2, "black", "black")

  }
  drawOpenNode() {
    nodeDrawer(ctx, this, 2, "black", "green")

  }
  drawClosedNode() {
    nodeDrawer(ctx, this, 2, "black", "pink")
  }
  drawPath() {
    nodeDrawer(ctx, this, 2, "black", "purple")
  }
  drawNode() {

    ctx.beginPath();
    ctx.lineWidth = "2"
    ctx.strokeStyle = "black"
    ctx.fillStyle = "white"
    ctx.fillRect(this.posx, this.posy, this.size, this.size)
    ctx.rect(this.posx, this.posy, this.size, this.size)
    ctx.closePath()
    ctx.stroke()
    if (this.inPath === true) {
      this.drawPath()
    }
    if (this.walkable === false) {

      this.createWall()
      return
    }
    if (this.posx == startPoint.x && this.posy == startPoint.y) {
      console.log("hit the startNode")
      this.createStartNode()
      return
    }
    if (this.posx == endPoint.x && this.posy == endPoint.y) {
      this.createEndNode()

    }

  }
}

const grid = new Grid(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0)

grid.createGrid()


function getDistance(nodeA, nodeB) {
    var distX = Math.abs(nodeA.posx - nodeB.posx)
    var distY = Math.abs(nodeA.posy - nodeB.posy)
  
    if (distX > distY) {
      return ((14 * distY) + (10 * (distX - distY)))
  
    }
    return (14 * distX + (10 * (distY - distX)))
  }


function nodeDrawer(context, target, lineW, strokeS, fillS) {
    context.beginPath();
    context.lineWidth = lineW;
    context.strokeStyle = strokeS;
    context.fillStyle = fillS;
    context.fillRect(target.posx, target.posy, target.size, target.size);
    context.rect(target.posx, target.posy, target.size, target.size);
    context.closePath();
    context.stroke();
} 